//
// Tencent is pleased to support the open source community by making trpc-agent-go available.
//
// Copyright (C) 2025 Tencent.
// All rights reserved.
//
// If you have downloaded a copy of the tRPC source code from Tencent,
// please note that tRPC source code is licensed under the  Apache 2.0 License,
// A copy of the Apache 2.0 License is included in this file.
//
//

// Package summary provides tools for automatic user information summarization.
package summary

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"trpc.group/trpc-go/trpc-agent-go/event"
	"trpc.group/trpc-go/trpc-agent-go/log"
	"trpc.group/trpc-go/trpc-agent-go/memory"
	"trpc.group/trpc-go/trpc-agent-go/model"
	"trpc.group/trpc-go/trpc-agent-go/session"
	"trpc.group/trpc-go/trpc-agent-go/tool"
)

const (
	// userSummarySessionPrefix is the prefix of the user summary session.
	userSummarySessionPrefix = "user-summary-"
)

// SummaryToolInput defines the input parameters for the summary tool.
type SummaryToolInput struct {
	// UserInfo is a one-sentence summary of user information.
	UserInfo string `json:"user_info"`
}

// SummaryToolOutput defines the output result of the summary tool.
type SummaryToolOutput struct {
	// Success indicates whether the storage operation was successful.
	Success bool `json:"success"`
	// Message contains the operation result message.
	Message string `json:"message"`
}

// SummaryTool implements automatic storage of user information summary.
type SummaryTool struct {
	memoryService  memory.Service
	sessionService session.Service
	appName        string
	userID         string
	name           string
	description    string
	inputSchema    *tool.Schema
	outputSchema   *tool.Schema
}

// NewSummaryTool creates a new summary tool instance.
func NewSummaryTool(memoryService memory.Service, sessionService session.Service, appName, userID string) *SummaryTool {
	// Generate input schema for the summary tool.
	inputSchema := &tool.Schema{
		Type: "object",
		Properties: map[string]*tool.Schema{
			"user_info": {
				Type: "string",
				Description: "A single-sentence summary of user information, such as preferences, personal details, " +
					"occupation, goals, or other facts that should be remembered for future interactions. " +
					"This should be generated by the LLM when it detects user-relevant information in the conversation.",
			},
		},
		Required: []string{"user_info"},
	}

	// Generate output schema for the summary tool.
	outputSchema := &tool.Schema{
		Type: "object",
		Properties: map[string]*tool.Schema{
			"success": {
				Type:        "boolean",
				Description: "Whether the storage operation was successful.",
			},
			"message": {
				Type:        "string",
				Description: "Operation result message.",
			},
		},
	}

	return &SummaryTool{
		memoryService:  memoryService,
		sessionService: sessionService,
		appName:        appName,
		userID:         userID,
		name:           "store_user_summary",
		description: "Automatically identify and store key user information, preferences, or personal facts " +
			"extracted from user messages. This tool is intended to persist concise, structured summaries " +
			"about the user—such as their name, interests, occupation, goals, or other relevant attributes—" +
			"so that the assistant can recall and leverage this information in future interactions. " +
			"The input should be a single, well-formed sentence summarizing the user's information, " +
			"as determined by the LLM's reasoning. Only call this tool when the current message contains " +
			"new or updated user-specific information that is valuable for long-term memory.",
		inputSchema:  inputSchema,
		outputSchema: outputSchema,
	}
}

// Call implements the tool.Tool interface.
// It stores the provided user summary into the user's summary session.
func (st *SummaryTool) Call(ctx context.Context, jsonArgs []byte) (any, error) {
	var input SummaryToolInput
	if err := json.Unmarshal(jsonArgs, &input); err != nil {
		return nil, fmt.Errorf("failed to unmarshal input: %w", err)
	}

	// Create the new summary event.
	evt := event.Event{
		Response: &model.Response{
			Choices: []model.Choice{
				{
					Message: model.Message{
						Role:    model.RoleUser,
						Content: input.UserInfo,
					},
				},
			},
		},
		Author:    "user",
		Timestamp: time.Now(),
	}

	summarySessionID := userSummarySessionPrefix + st.userID

	// Try to get the existing session from sessionService.
	sess, err := st.sessionService.GetSession(ctx, session.Key{
		AppName:   st.appName,
		UserID:    st.userID,
		SessionID: summarySessionID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get summary session: %w", err)
	}
	if sess == nil {
		// Create a new session if not found.
		log.Debugf("Creating new summary session: %v", summarySessionID)
		sess, err = st.sessionService.CreateSession(ctx, session.Key{
			AppName:   st.appName,
			UserID:    st.userID,
			SessionID: summarySessionID,
		}, session.StateMap{})
		if err != nil {
			return nil, fmt.Errorf("failed to create summary session: %w", err)
		}
	}

	// Append the new event to the session using sessionService.
	if err := st.sessionService.AppendEvent(ctx, sess, &evt); err != nil {
		return nil, fmt.Errorf("failed to append summary event: %w", err)
	}

	if err := st.memoryService.AddSessionToMemory(ctx, sess); err != nil {
		return SummaryToolOutput{
			Success: false,
			Message: fmt.Sprintf("Failed to store summary: %v", err),
		}, fmt.Errorf("failed to add session to memory: %w", err)
	}

	return SummaryToolOutput{
		Success: true,
		Message: fmt.Sprintf("User summary stored successfully: %v", input.UserInfo),
	}, nil
}

// Declaration returns the tool declaration.
func (st *SummaryTool) Declaration() *tool.Declaration {
	return &tool.Declaration{
		Name:         st.name,
		Description:  st.description,
		InputSchema:  st.inputSchema,
		OutputSchema: st.outputSchema,
	}
}
